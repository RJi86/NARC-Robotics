- camera
- remove any distance measurements
- vector implementation

#include "MultiplexerAngle.h"
#include "GoalDetection.h"
#include "VectorMotorControl.h" // Using the new vector-based motor control
#include "LDR.h"

// Create objects
MultiplexerAngle ballSensor;     c
GoalDetection goalDetector;
VectorMotorControl motors; // Changed from MotorClass to VectorMotorControl
LDR boundarySensor(42, 41, 40, A0); // Adjust pins as needed

// Robot states
enum RobotState {
  FIND_BALL,
  APPROACH_BALL,
  CATCH_BALL,
  FIND_GOAL,
  APPROACH_GOAL,
  AVOID_BOUNDARY
};

RobotState currentState = FIND_BALL;
RobotState previousState = FIND_BALL; // To return after boundary avoidance

// Settings
const float ROTATION_SPEED = 70;      // Speed for rotation (0-255)
const float APPROACH_SPEED = 120;     // Speed for moving toward ball/goal (0-255)
const float BOUNDARY_ESCAPE_SPEED = 150; // Speed to move away from boundary
const unsigned long BOUNDARY_ESCAPE_TIME = 500; // Time to move away from boundary (ms)
const unsigned long CATCH_TIME = 1000; // Time to confirm ball catch (ms)
const float ANGLE_STABLE_THRESHOLD = 3.0; // Max angle change to consider stable (degrees)

// Angle smoothing for distant balls
const int READINGS_COUNT = 5;
float recentReadings[READINGS_COUNT] = {-1, -1, -1, -1, -1};
int readingIndex = 0;

// Tracking variables
float lastBallAngle = -1;
unsigned long stableAngleStartTime = 0;
unsigned long boundaryDetectedTime = 0;
bool ballCaught = false;

void setup() {
  Serial.begin(115200);
  
  // Initialize systems
  ballSensor.begin();
  goalDetector.begin();
  boundarySensor.begin();
  motors.begin(); // Initialize vector-based motor control
  
  Serial.println("Soccer Robot initialized with vector-based motor control!");
}

void loop() {
  // Update sensors
  ballSensor.findBallAngle(false, 100); // Less frequent debug output
  goalDetector.update();
  
  // Check for boundary first - highest priority
  float boundaryAngle = boundarySensor.angleOfLine();
  if (boundaryAngle >= 0 && currentState != AVOID_BOUNDARY) {
    Serial.print("Boundary detected at angle: ");
    Serial.println(boundaryAngle);
    previousState = currentState;
    currentState = AVOID_BOUNDARY;
    boundaryDetectedTime = millis();
  }
  
  float ballAngle = ballSensor.getLatestAngle();
  bool goalDetected = goalDetector.isEnemyGoalDetected();
  
  // Main state machine
  switch (currentState) {
    case AVOID_BOUNDARY:
      {
        // Calculate escape angle (opposite of boundary)
        float escapeAngle = boundaryAngle + PI;
        if (escapeAngle > 2 * PI) escapeAngle -= 2 * PI;
        
        // Move away from boundary
        motors.MoveDirection(escapeAngle, BOUNDARY_ESCAPE_SPEED);
        
        // After escaping for the set time, return to previous state
        if (millis() - boundaryDetectedTime > BOUNDARY_ESCAPE_TIME) {
          Serial.println("Boundary avoided, returning to previous state");
          currentState = previousState;
          motors.Stop();
        }
      }
      break;
      
    case FIND_BALL:
      if (ballAngle >= 0) {
        Serial.println("Ball found! Approaching...");
        currentState = APPROACH_BALL;
        
        // Reset angle smoothing
        for (int i = 0; i < READINGS_COUNT; i++) {
          recentReadings[i] = -1;
        }
      } else {
        // Rotate to search for ball
        motors.Rotation(0, ROTATION_SPEED);
      }
      break;
      
    case APPROACH_BALL:
      if (ballAngle < 0) {
        // Lost the ball
        Serial.println("Ball lost! Searching again...");
        currentState = FIND_BALL;
        motors.Stop();
      } else {
        // Get smoothed angle for more stable movement
        float smoothedAngle = getSmoothedAngle(ballAngle);
        
        // Calculate confidence based on sensor count
        int activeSensors = countActiveSensors();
        float confidence = float(activeSensors) / 10.0; // 0.1 to ~2.4
        if (confidence > 1.0) confidence = 1.0;
        
        // Adjust speed based on confidence (slower for distant balls)
        float adjustedSpeed = APPROACH_SPEED * (0.5 + (0.5 * confidence));
        
        // Convert angle to radians and approach ball
        float approachAngle = smoothedAngle * (PI / 180.0);
        
        // Move toward ball with adjusted speed
        motors.MoveDirection(approachAngle, adjustedSpeed);
        
        // If we have a very strong reading (ball is close), prepare to catch
        if (activeSensors >= 5 || (activeSensors >= 3 && abs(smoothedAngle) < 10.0)) {
          Serial.println("Ball close! Confirming catch...");
          currentState = CATCH_BALL;
          stableAngleStartTime = millis();
          lastBallAngle = smoothedAngle;
        }
      }
      break;
      
    case CATCH_BALL:
      if (ballAngle < 0) {
        // Lost the ball
        Serial.println("Ball lost during catch! Searching again...");
        currentState = FIND_BALL;
        motors.Stop();
        ballCaught = false;
      } else {
        // Get smoothed angle
        float smoothedAngle = getSmoothedAngle(ballAngle);
        
        // Slowly approach if not centered (mouth alignment)
        if (abs(smoothedAngle) > 15.0) {
          // Ball not centered, adjust position
          float approachAngle = smoothedAngle * (PI / 180.0);
          motors.MoveDirection(approachAngle, APPROACH_SPEED * 0.4);
          
          // Reset timer since we're still moving
          stableAngleStartTime = millis();
          lastBallAngle = smoothedAngle;
        } else {
          // Ball is centered, check stability
          motors.Stop();
          
          // Check if angle is stable (ball caught)
          if (abs(smoothedAngle - lastBallAngle) <= ANGLE_STABLE_THRESHOLD) {
            // Angle is stable, check if stable for required time
            if (millis() - stableAngleStartTime >= CATCH_TIME) {
              Serial.println("Ball caught! Finding goal...");
              ballCaught = true;
              currentState = FIND_GOAL;
            }
          } else {
            // Angle changed, reset timer
            stableAngleStartTime = millis();
            lastBallAngle = smoothedAngle;
          }
        }
      }
      break;
      
    case FIND_GOAL:
      if (!ballCaught) {
        // Lost the ball somehow
        Serial.println("Ball lost! Starting over...");
        currentState = FIND_BALL;
        motors.Stop();
      } else if (goalDetected) {
        Serial.println("Goal found! Approaching...");
        currentState = APPROACH_GOAL;
      } else {
        // Rotate slowly to find goal
        motors.Rotation(0, ROTATION_SPEED * 0.7);
        
        // Double-check we still have the ball
        if (ballAngle < 0 || countActiveSensors() < 3) {
          Serial.println("Ball lost while finding goal!");
          ballCaught = false;
        }
      }
      break;
      
    case APPROACH_GOAL:
      if (!ballCaught) {
        // Lost the ball somehow
        Serial.println("Ball lost! Starting over...");
        currentState = FIND_BALL;
        motors.Stop();
      } else if (!goalDetected) {
        Serial.println("Goal lost! Finding goal again...");
        currentState = FIND_GOAL;
        motors.Stop();
      } else {
        // Move toward goal
        const GoalData& goal = goalDetector.getEnemyGoalData();
        
        // Get goal heading - now we can use the advanced movement capabilities
        float goalDirection = 0.0f;  // Forward direction
        float rotation = 0.0f;      // No rotation initially
        
        // Calculate any needed rotation to keep goal centered
        if (goal.x < 150) {
          // Goal is left of center - add slight rotation while moving
          rotation = -0.2f;  // Small counterclockwise rotation
        } else if (goal.x > 170) {
          // Goal is right of center - add slight rotation while moving
          rotation = 0.2f;   // Small clockwise rotation
        }
        
        // Use combined movement and rotation (more efficient than the previous method)
        motors.MoveWithRotation(goalDirection, rotation, APPROACH_SPEED);
        
        // Check if we've reached the goal
        if (goal.distance < 20) {  // Assuming distance is in cm
          // We scored!
          Serial.println("GOAL SCORED!");
          motors.Stop();
          
          // Start over
          currentState = FIND_BALL;
          ballCaught = false;
        }
      }
      break;
  }
  
  // Short delay
  delay(10);
}

// Get smoothed angle by averaging recent readings
float getSmoothedAngle(float newAngle) {
  // Add new reading to array
  recentReadings[readingIndex] = newAngle;
  readingIndex = (readingIndex + 1) % READINGS_COUNT;
  
  // Count valid readings and calculate average
  float sum = 0;
  int validCount = 0;
  for (int i = 0; i < READINGS_COUNT; i++) {
    if (recentReadings[i] >= 0) {
      sum += recentReadings[i];
      validCount++;
    }
  }
  
  if (validCount == 0) return -1;
  return sum / validCount;
}

// Count how many IR sensors are active (for ball proximity detection)
int countActiveSensors() {
  int count = 0;
  for (int i = 0; i < 24; i++) {
    if (ballSensor.getSensorDetection(i)) {
      count++;
    }
  }
  return count;
}